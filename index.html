<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ArchViz Studio - Node-Based Architecture Modeler</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three-csg-ts@3.1.13/lib/three-csg.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --bg-dark: #0f0f0f;
            --bg-primary: #1a1a1a;
            --bg-secondary: #242424;
            --bg-tertiary: #2e2e2e;
            --accent: #00e5ff;
            --accent-hover: #00c4db;
            --accent-glow: rgba(0, 229, 255, 0.2);
            --text-primary: #ffffff;
            --text-secondary: #9e9e9e;
            --node-bg: #2a2a2a;
            --node-border: #404040;
            --success: #00ff9d;
            --warning: #ffaa00;
            --error: #ff4757;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: var(--bg-dark);
            color: var(--text-primary);
            overflow: hidden;
            height: 100vh;
        }

        .app-container {
            display: grid;
            grid-template-columns: 280px 1fr 320px;
            grid-template-rows: 60px 1fr 40px;
            height: 100vh;
            gap: 0;
        }

        /* Header */
        .header {
            grid-column: 1 / -1;
            background: var(--bg-primary);
            border-bottom: 2px solid var(--accent);
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 24px;
            box-shadow: 0 2px 20px rgba(0, 229, 255, 0.1);
        }

        .logo {
            font-size: 20px;
            font-weight: 700;
            color: var(--accent);
            display: flex;
            align-items: center;
            gap: 12px;
            letter-spacing: -0.5px;
            text-shadow: 0 0 20px var(--accent-glow);
        }

        .logo-icon {
            font-size: 28px;
        }

        .header-actions {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .btn {
            padding: 10px 20px;
            border: 1px solid var(--node-border);
            border-radius: 6px;
            cursor: pointer;
            font-size: 13px;
            font-weight: 600;
            transition: all 0.2s;
            background: var(--bg-secondary);
            color: var(--text-primary);
        }

        .btn:hover {
            background: var(--bg-tertiary);
            border-color: var(--accent);
            transform: translateY(-1px);
        }

        .btn-primary {
            background: var(--accent);
            border-color: var(--accent);
            color: var(--bg-dark);
        }

        .btn-primary:hover {
            background: var(--accent-hover);
            box-shadow: 0 4px 20px var(--accent-glow);
        }

        /* Sidebar */
        .sidebar {
            background: var(--bg-primary);
            border-right: 1px solid var(--node-border);
            overflow-y: auto;
            padding: 20px 16px;
        }

        .sidebar-section {
            margin-bottom: 24px;
        }

        .section-title {
            margin-bottom: 12px;
            color: var(--text-secondary);
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 1.5px;
            font-weight: 700;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .section-title::before {
            content: '';
            width: 3px;
            height: 12px;
            background: var(--accent);
            border-radius: 2px;
        }

        .node-palette {
            display: grid;
            gap: 8px;
        }

        .palette-node {
            padding: 12px;
            background: var(--node-bg);
            border: 2px solid var(--node-border);
            border-radius: 8px;
            cursor: grab;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .palette-node:hover {
            border-color: var(--accent);
            background: var(--bg-tertiary);
            transform: translateX(4px);
            box-shadow: 0 4px 12px rgba(0, 229, 255, 0.15);
        }

        .palette-node:active {
            cursor: grabbing;
            transform: scale(0.98);
        }

        .node-icon {
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            background: var(--bg-tertiary);
            border-radius: 6px;
            flex-shrink: 0;
        }

        .node-info {
            flex: 1;
            min-width: 0;
        }

        .node-title {
            font-weight: 600;
            font-size: 13px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .node-desc {
            font-size: 10px;
            color: var(--text-secondary);
            margin-top: 2px;
        }

        /* Main Content */
        .main-content {
            display: grid;
            grid-template-rows: 1fr 1fr;
            gap: 1px;
            background: var(--bg-dark);
        }

        /* 3D Viewport */
        .viewport-container {
            position: relative;
            background: var(--bg-secondary);
            overflow: hidden;
        }

        #viewport {
            width: 100%;
            height: 100%;
            display: block;
        }

        .viewport-overlay {
            position: absolute;
            top: 16px;
            left: 16px;
            display: flex;
            gap: 10px;
            pointer-events: none;
        }

        .viewport-overlay > * {
            pointer-events: all;
        }

        .view-controls {
            background: rgba(26, 26, 26, 0.95);
            border: 1px solid var(--node-border);
            border-radius: 8px;
            padding: 6px;
            display: flex;
            gap: 6px;
            backdrop-filter: blur(10px);
        }

        .view-btn {
            width: 36px;
            height: 36px;
            border: none;
            border-radius: 6px;
            background: var(--bg-tertiary);
            color: var(--text-primary);
            cursor: pointer;
            font-size: 11px;
            font-weight: 700;
            transition: all 0.2s;
        }

        .view-btn:hover {
            background: var(--accent);
            color: var(--bg-dark);
            transform: scale(1.05);
        }

        .viewport-info {
            position: absolute;
            bottom: 16px;
            left: 16px;
            background: rgba(26, 26, 26, 0.95);
            border: 1px solid var(--node-border);
            border-radius: 8px;
            padding: 10px 14px;
            font-size: 11px;
            color: var(--text-secondary);
            backdrop-filter: blur(10px);
        }

        /* Node Canvas */
        .canvas-container {
            position: relative;
            overflow: hidden;
            background: 
                radial-gradient(circle at 50% 50%, rgba(0, 229, 255, 0.03) 0%, transparent 50%),
                linear-gradient(90deg, rgba(255,255,255,0.02) 1px, transparent 1px),
                linear-gradient(rgba(255,255,255,0.02) 1px, transparent 1px);
            background-size: 100% 100%, 30px 30px, 30px 30px;
            background-color: var(--bg-secondary);
        }

        #canvas {
            position: absolute;
            cursor: grab;
            transform-origin: 0 0;
        }

        #canvas.panning {
            cursor: grabbing;
        }

        .workflow-node {
            position: absolute;
            background: linear-gradient(135deg, var(--node-bg) 0%, rgba(42, 42, 42, 0.8) 100%);
            border: 2px solid var(--node-border);
            border-radius: 10px;
            min-width: 180px;
            max-width: 250px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
            transition: all 0.2s;
            backdrop-filter: blur(10px);
        }

        .workflow-node:hover {
            box-shadow: 0 12px 40px rgba(0, 229, 255, 0.2);
            border-color: var(--accent);
        }

        .workflow-node.selected {
            border-color: var(--accent);
            box-shadow: 0 0 0 3px rgba(0, 229, 255, 0.3);
        }

        .workflow-node.executing {
            animation: nodeExecute 0.6s ease-in-out;
        }

        @keyframes nodeExecute {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.08); box-shadow: 0 12px 40px var(--accent-glow); }
        }

        .node-header {
            padding: 12px;
            background: linear-gradient(135deg, var(--bg-tertiary) 0%, var(--node-bg) 100%);
            border-bottom: 1px solid var(--node-border);
            border-radius: 8px 8px 0 0;
            display: flex;
            align-items: center;
            gap: 10px;
            cursor: move;
        }

        .node-header-icon {
            font-size: 18px;
        }

        .node-header-title {
            font-weight: 600;
            font-size: 13px;
            flex: 1;
        }

        .node-body {
            padding: 12px;
        }

        .node-param {
            margin-bottom: 10px;
            position: relative;
        }

        .node-param .param-label {
            margin-bottom: 0;
        }

        .node-param .port.input {
            margin-bottom: 5px;
        }

        .node-param .param-input {
            padding-left: 20px;
        }

        .node-param:last-child {
            margin-bottom: 0;
        }

        .param-label {
            font-size: 10px;
            color: var(--text-secondary);
            margin-bottom: 5px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            font-weight: 600;
        }

        .param-input {
            width: 100%;
            padding: 7px 10px;
            background: var(--bg-tertiary);
            border: 1px solid var(--node-border);
            border-radius: 5px;
            color: var(--text-primary);
            font-size: 12px;
            transition: all 0.2s;
        }

        .param-input:focus {
            outline: none;
            border-color: var(--accent);
            box-shadow: 0 0 0 3px rgba(0, 229, 255, 0.1);
        }

        .node-ports {
            display: flex;
            flex-direction: column;
            gap: 8px;
            margin-top: 12px;
        }

        .port {
            display: flex;
            align-items: center;
            gap: 8px;
            position: relative;
            font-size: 11px;
        }

        .port.input {
            justify-content: flex-start;
        }

        .port.output {
            justify-content: flex-end;
        }

        .port-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: var(--accent);
            border: 2px solid var(--node-bg);
            cursor: pointer;
            transition: all 0.2s;
            position: relative;
            z-index: 10;
            flex-shrink: 0;
            box-shadow: 0 0 8px rgba(0, 229, 255, 0.4);
        }

        .port-dot:hover {
            transform: scale(1.5);
            box-shadow: 0 0 16px var(--accent);
        }

        .port-label {
            font-size: 11px;
            color: var(--text-secondary);
            font-weight: 500;
        }

        /* Properties Panel */
        .properties-panel {
            background: var(--bg-primary);
            border-left: 1px solid var(--node-border);
            overflow-y: auto;
            padding: 20px;
        }

        .prop-section {
            margin-bottom: 28px;
        }

        .prop-section-title {
            margin-bottom: 16px;
            color: var(--accent);
            font-size: 14px;
            font-weight: 700;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .prop-section-title::before {
            content: '';
            width: 4px;
            height: 16px;
            background: var(--accent);
            border-radius: 2px;
        }

        .prop-group {
            margin-bottom: 14px;
        }

        .prop-label {
            font-size: 11px;
            color: var(--text-secondary);
            margin-bottom: 6px;
            display: flex;
            justify-content: space-between;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            font-weight: 600;
        }

        .prop-value {
            color: var(--accent);
            font-weight: 700;
        }

        .prop-input, .prop-select {
            width: 100%;
            padding: 10px;
            background: var(--bg-secondary);
            border: 1px solid var(--node-border);
            border-radius: 6px;
            color: var(--text-primary);
            font-size: 13px;
            transition: all 0.2s;
        }

        .prop-input:focus, .prop-select:focus {
            outline: none;
            border-color: var(--accent);
            box-shadow: 0 0 0 3px rgba(0, 229, 255, 0.1);
        }

        .prop-slider {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: var(--bg-secondary);
            outline: none;
            -webkit-appearance: none;
        }

        .prop-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: var(--accent);
            cursor: pointer;
            box-shadow: 0 2px 8px rgba(0, 229, 255, 0.4);
        }

        .prop-slider::-moz-range-thumb {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: var(--accent);
            cursor: pointer;
            border: none;
        }

        .geometry-list {
            max-height: 300px;
            overflow-y: auto;
        }

        .geometry-item {
            padding: 10px;
            background: var(--bg-secondary);
            border: 1px solid var(--node-border);
            border-radius: 6px;
            margin-bottom: 8px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 12px;
            transition: all 0.2s;
        }

        .geometry-item:hover {
            border-color: var(--accent);
            background: var(--bg-tertiary);
        }

        .delete-btn {
            background: var(--error);
            border: none;
            color: white;
            padding: 5px 10px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 10px;
            font-weight: 600;
            transition: all 0.2s;
        }

        .delete-btn:hover {
            background: #ff6b7a;
            transform: scale(1.05);
        }

        /* Footer */
        .footer {
            grid-column: 1 / -1;
            background: var(--bg-primary);
            border-top: 1px solid var(--node-border);
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 20px;
            font-size: 11px;
            color: var(--text-secondary);
        }

        .zoom-controls {
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .zoom-btn {
            width: 28px;
            height: 28px;
            border: 1px solid var(--node-border);
            border-radius: 4px;
            background: var(--bg-secondary);
            color: var(--text-primary);
            cursor: pointer;
            font-size: 16px;
            font-weight: 700;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
        }

        .zoom-btn:hover {
            background: var(--accent);
            color: var(--bg-dark);
            border-color: var(--accent);
        }

        /* SVG Connections */
        #connections-svg {
            position: absolute;
            top: 0;
            left: 0;
            pointer-events: none;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        .connection-path {
            fill: none;
            stroke: var(--accent);
            stroke-width: 3;
            opacity: 0.6;
            filter: drop-shadow(0 0 4px rgba(0, 229, 255, 0.4));
            transition: all 0.2s;
        }

        .connection-path.selected {
            stroke: var(--accent-hover);
            stroke-width: 5;
            opacity: 1;
        }

        /* Scrollbar */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        ::-webkit-scrollbar-track {
            background: var(--bg-primary);
        }

        ::-webkit-scrollbar-thumb {
            background: var(--bg-tertiary);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: var(--accent);
        }

        .checkbox-label {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 12px;
            cursor: pointer;
            padding: 8px 0;
        }

        .checkbox-label input[type="checkbox"] {
            width: 16px;
            height: 16px;
            cursor: pointer;
        }

        .empty-state {
            color: var(--text-secondary);
            font-size: 11px;
            text-align: center;
            padding: 32px 20px;
            line-height: 1.6;
        }

        .hint-text {
            font-size: 10px;
            color: var(--text-secondary);
            margin-top: 8px;
            padding: 8px;
            background: rgba(0, 229, 255, 0.05);
            border-radius: 4px;
            border-left: 2px solid var(--accent);
        }

        /* Context Menu */
        .context-menu {
            position: absolute;
            z-index: 1000;
            background: rgba(40, 40, 40, 0.8);
            border: 1px solid var(--node-border);
            border-radius: 8px;
            padding: 8px;
            display: none;
            backdrop-filter: blur(10px);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
        }

        .context-menu-item {
            padding: 10px 15px;
            color: var(--text-primary);
            cursor: pointer;
            border-radius: 5px;
            font-size: 13px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .context-menu-item:hover {
            background: var(--accent);
            color: var(--bg-dark);
        }

        .context-menu-icon {
            font-size: 16px;
        }
    </style>
</head>
<body>
    <div class="app-container">
        <!-- Header -->
        <div class="header">
            <div class="logo">
                <span class="logo-icon">⬢</span>
                <span>ARCHVIZ STUDIO</span>
            </div>
            <div class="header-actions">
                <button class="btn" onclick="addBasicWallBlock()">Add Basic Wall Block</button>
                <button class="btn" onclick="clearAll()">Clear All</button>
                <button class="btn btn-primary" onclick="generateModel()">▶ Generate Model</button>
            </div>
        </div>

        <!-- Sidebar -->
        <div class="sidebar">
            <div class="sidebar-section">
                <div class="section-title">Primitives</div>
                <div class="node-palette">
                    <div class="palette-node" draggable="true" data-type="box" title="Creates a box primitive.">
                        <div class="node-icon">▢</div>
                        <div class="node-info">
                            <div class="node-title">Box</div>
                            <div class="node-desc">Basic cube shape</div>
                        </div>
                    </div>
                    <div class="palette-node" draggable="true" data-type="cylinder" title="Creates a cylinder primitive.">
                        <div class="node-icon">◯</div>
                        <div class="node-info">
                            <div class="node-title">Cylinder</div>
                            <div class="node-desc">Column or pipe</div>
                        </div>
                    </div>
                    <div class="palette-node" draggable="true" data-type="sphere" title="Creates a sphere primitive.">
                        <div class="node-icon">●</div>
                        <div class="node-info">
                            <div class="node-title">Sphere</div>
                            <div class="node-desc">Dome or ball</div>
                        </div>
                    </div>
                    <div class="palette-node" draggable="true" data-type="plane" title="Creates a plane primitive.">
                        <div class="node-icon">▬</div>
                        <div class="node-info">
                            <div class="node-title">Plane</div>
                            <div class="node-desc">Flat surface</div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="sidebar-section">
                <div class="section-title">Architecture</div>
                <div class="node-palette">
                    <div class="palette-node" draggable="true" data-type="wall" title="Creates a wall.">
                        <div class="node-icon">▯</div>
                        <div class="node-info">
                            <div class="node-title">Wall</div>
                            <div class="node-desc">Vertical partition</div>
                        </div>
                    </div>
                    <div class="palette-node" draggable="true" data-type="window" title="Creates a window.">
                        <div class="node-icon">⬚</div>
                        <div class="node-info">
                            <div class="node-title">Window</div>
                            <div class="node-desc">Glass opening</div>
                        </div>
                    </div>
                    <div class="palette-node" draggable="true" data-type="door" title="Creates a door.">
                        <div class="node-icon">▭</div>
                        <div class="node-info">
                            <div class="node-title">Door</div>
                            <div class="node-desc">Entry point</div>
                        </div>
                    </div>
                    <div class="palette-node" draggable="true" data-type="stairs" title="Creates a flight of stairs.">
                        <div class="node-icon">≡</div>
                        <div class="node-info">
                            <div class="node-title">Stairs</div>
                            <div class="node-desc">Step sequence</div>
                        </div>
                    </div>
                    <div class="palette-node" draggable="true" data-type="roof" title="Creates a gabled roof.">
                        <div class="node-icon">△</div>
                        <div class="node-info">
                            <div class="node-title">Roof</div>
                            <div class="node-desc">Gabled roof</div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="sidebar-section">
                <div class="section-title">Operations</div>
                <div class="node-palette">
                    <div class="palette-node" draggable="true" data-type="array" title="Creates an array of the input geometry.">
                        <div class="node-icon">▦</div>
                        <div class="node-info">
                            <div class="node-title">Array</div>
                            <div class="node-desc">Repeat pattern</div>
                        </div>
                    </div>
                    <div class="palette-node" draggable="true" data-type="transform" title="Transforms the input geometry.">
                        <div class="node-icon">⤨</div>
                        <div class="node-info">
                            <div class="node-title">Transform</div>
                            <div class="node-desc">Move/rotate/scale</div>
                        </div>
                    </div>
                    <div class="palette-node" draggable="true" data-type="material" title="Applies a material to the input geometry.">
                        <div class="node-icon">🎨</div>
                        <div class="node-info">
                            <div class="node-title">Material</div>
                            <div class="node-desc">Surface style</div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="sidebar-section">
                <div class="section-title">Output</div>
                <div class="node-palette">
                    <div class="palette-node" draggable="true" data-type="output" title="Outputs the final geometry to the 3D viewport.">
                        <div class="node-icon">→</div>
                        <div class="node-info">
                            <div class="node-title">Output</div>
                            <div class="node-desc">Final geometry</div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="hint-text">
                💡 Drag nodes to canvas, connect ports to build workflow, then click Generate!
            </div>
        </div>

        <!-- Main Content -->
        <div class="main-content">
            <!-- 3D Viewport -->
            <div class="viewport-container">
                <canvas id="viewport"></canvas>
                <div class="viewport-overlay">
                    <div class="view-controls">
                        <button class="view-btn" onclick="setView('top')" title="Top View">T</button>
                        <button class="view-btn" onclick="setView('front')" title="Front View">F</button>
                        <button class="view-btn" onclick="setView('side')" title="Side View">S</button>
                        <button class="view-btn" onclick="setView('iso')" title="Isometric">3D</button>
                    </div>
                </div>
                <div class="viewport-info">
                    <span id="poly-count">Polygons: 0</span> • 
                    <span id="object-count">Objects: 0</span>
                </div>
            </div>

            <!-- Node Canvas -->
            <div class="canvas-container" id="canvas-container">
                <svg id="connections-svg"></svg>
                <div id="canvas"></div>
            </div>
        </div>

        <!-- Properties Panel -->
        <div class="properties-panel">
            <div class="prop-section">
                <div class="prop-section-title">Scene Objects</div>
                <div class="geometry-list" id="geometry-list">
                    <div class="empty-state">
                        No objects yet.<br>
                        Create a workflow and click Generate!
                    </div>
                </div>
            </div>

            <div class="prop-section" id="node-properties" style="display: none;">
                <div class="prop-section-title">Node Properties</div>
                <div id="properties-content"></div>
            </div>

            <div class="prop-section">
                <div class="prop-section-title">Viewport</div>
                <div class="prop-group">
                    <label class="checkbox-label">
                        <input type="checkbox" id="grid-toggle" checked onchange="toggleGrid(this.checked)">
                        <span>Show Grid</span>
                    </label>
                </div>
                <div class="prop-group">
                    <label class="checkbox-label">
                        <input type="checkbox" id="axes-toggle" checked onchange="toggleAxes(this.checked)">
                        <span>Show Axes</span>
                    </label>
                </div>
            </div>
        </div>

        <!-- Footer -->
        <div class="footer">
            <div class="zoom-controls">
                <button class="zoom-btn" onclick="zoomCanvas('in')">+</button>
                <span id="zoom-level">100%</span>
                <button class="zoom-btn" onclick="zoomCanvas('out')">−</button>
                <button class="zoom-btn" onclick="resetZoom()" title="Reset">⊙</button>
            </div>
            <div>Nodes: <span id="node-count">0</span> • Connections: <span id="connection-count">0</span></div>
            <div>ArchViz Studio v1.0</div>
        </div>
    </div>

    <!-- Context Menu -->
    <div id="context-menu" class="context-menu"></div>

    <script>
        // THREE.JS Scene Setup
        let scene, camera, renderer;
        let gridHelper, axesHelper;
        let sceneObjects = [];

        function initViewport() {
            const canvas = document.getElementById('viewport');
            const container = canvas.parentElement;

            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x0f0f0f);

            camera = new THREE.PerspectiveCamera(50, container.clientWidth / container.clientHeight, 0.1, 1000);
            camera.position.set(20, 15, 20);
            camera.lookAt(0, 0, 0);

            renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
            renderer.setSize(container.clientWidth, container.clientHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.shadowMap.enabled = true;

            // Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(10, 20, 10);
            directionalLight.castShadow = true;
            scene.add(directionalLight);

            const directionalLight2 = new THREE.DirectionalLight(0x00e5ff, 0.3);
            directionalLight2.position.set(-10, 5, -10);
            scene.add(directionalLight2);

            // Grid
            gridHelper = new THREE.GridHelper(30, 30, 0x00e5ff, 0x333333);
            scene.add(gridHelper);

            // Axes
            axesHelper = new THREE.AxesHelper(8);
            scene.add(axesHelper);

            setupOrbitControls(canvas);
            animate();
        }

        function setupOrbitControls(canvas) {
            let isDragging = false;
            let previousMouse = { x: 0, y: 0 };
            let rotation = { x: -0.5, y: 0.8 };
            const radius = 30;

            canvas.addEventListener('mousedown', (e) => {
                if (e.button === 0) {
                    isDragging = true;
                    previousMouse = { x: e.clientX, y: e.clientY };
                }
            });

            document.addEventListener('mousemove', (e) => {
                if (isDragging) {
                    const deltaX = e.clientX - previousMouse.x;
                    const deltaY = e.clientY - previousMouse.y;

                    rotation.y += deltaX * 0.005;
                    rotation.x += deltaY * 0.005;
                    rotation.x = Math.max(-Math.PI / 2 + 0.1, Math.min(Math.PI / 2 - 0.1, rotation.x));

                    updateCamera();
                    previousMouse = { x: e.clientX, y: e.clientY };
                }
            });

            document.addEventListener('mouseup', () => {
                isDragging = false;
            });

            canvas.addEventListener('wheel', (e) => {
                e.preventDefault();
                const currentRadius = camera.position.length();
                const newRadius = Math.max(5, Math.min(60, currentRadius + e.deltaY * 0.05));
                camera.position.multiplyScalar(newRadius / currentRadius);
            });

            function updateCamera() {
                camera.position.x = radius * Math.cos(rotation.x) * Math.sin(rotation.y);
                camera.position.y = radius * Math.sin(rotation.x);
                camera.position.z = radius * Math.cos(rotation.x) * Math.cos(rotation.y);
                camera.lookAt(0, 0, 0);
            }

            updateCamera();
        }

        function animate() {
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
        }

        function setView(view) {
            const distance = 30;
            switch(view) {
                case 'top':
                    camera.position.set(0, distance, 0);
                    break;
                case 'front':
                    camera.position.set(0, 5, distance);
                    break;
                case 'side':
                    camera.position.set(distance, 5, 0);
                    break;
                case 'iso':
                    camera.position.set(20, 15, 20);
                    break;
            }
            camera.lookAt(0, 0, 0);
        }

        function toggleGrid(show) {
            gridHelper.visible = show;
        }

        function toggleAxes(show) {
            axesHelper.visible = show;
        }

        function addBasicWallBlock() {
            const geometry = new THREE.BoxGeometry(1, 1, 1);
            const material = new THREE.MeshStandardMaterial({ color: 0x00ff00 });
            const cube = new THREE.Mesh(geometry, material);
            scene.add(cube);
            sceneObjects.push(cube);
            updateViewportStats();
            updateGeometryList();
        }

        function updateViewportStats() {
            let totalPolygons = 0;
            sceneObjects.forEach(obj => {
                obj.traverse((child) => {
                    if (child.geometry && child.geometry.attributes.position) {
                        totalPolygons += child.geometry.attributes.position.count / 3;
                    }
                });
            });
            document.getElementById('poly-count').textContent = `Polygons: ${Math.floor(totalPolygons)}`;
            document.getElementById('object-count').textContent = `Objects: ${sceneObjects.length}`;
        }

        // Node System
        let nodes = [];
        let connections = [];
        let nodeIdCounter = 0;
        let selectedNode = null;
        let connectingFrom = null;
        let canvasOffset = { x: 0, y: 0 };
        let zoom = 1;
        let isPanning = false;
        let panStart = { x: 0, y: 0 };

        const canvas = document.getElementById('canvas');
        const canvasContainer = document.getElementById('canvas-container');
        const connectionsSvg = document.getElementById('connections-svg');

        const nodeTemplates = {
            'number': {
                title: 'Number',
                icon: '#',
                inputs: [],
                outputs: ['Value'],
                params: { value: 1 },
                color: '#18a'
            },
            'box': {
                title: 'Box',
                icon: '▢',
                inputs: [],
                outputs: ['Geometry'],
                params: { width: 5, height: 5, depth: 5, x: 0, y: 2.5, z: 0 },
                color: '#4a90e2'
            },
            'cylinder': {
                title: 'Cylinder',
                icon: '◯',
                inputs: [],
                outputs: ['Geometry'],
                params: { radius: 2, height: 5, segments: 32, x: 0, y: 2.5, z: 0 },
                color: '#5c7cfa'
            },
            'sphere': {
                title: 'Sphere',
                icon: '●',
                inputs: [],
                outputs: ['Geometry'],
                params: { radius: 3, segments: 32, x: 0, y: 3, z: 0 },
                color: '#748ffc'
            },
            'plane': {
                title: 'Plane',
                icon: '▬',
                inputs: [],
                outputs: ['Geometry'],
                params: { width: 20, height: 20, x: 0, y: 0, z: 0 },
                color: '#868e96'
            },
            'wall': {
                title: 'Wall',
                icon: '▯',
                inputs: [],
                outputs: ['Geometry'],
                params: { length: 10, height: 3, thickness: 0.2, x: 0, y: 1.5, z: 0 },
                color: '#adb5bd'
            },
            'window': {
                title: 'Window',
                icon: '⬚',
                inputs: ['Wall'],
                outputs: ['Geometry'],
                params: { width: 2, height: 1.5, depth: 0.3, x: 0, y: 1.5, z: 0 },
                color: '#74c0fc'
            },
            'door': {
                title: 'Door',
                icon: '▭',
                inputs: ['Wall'],
                outputs: ['Geometry'],
                params: { width: 1, height: 2.2, depth: 0.1, x: 0, y: 1.1, z: 0 },
                color: '#a0785d'
            },
            'stairs': {
                title: 'Stairs',
                icon: '≡',
                inputs: [],
                outputs: ['Geometry'],
                params: { steps: 10, width: 3, stepHeight: 0.2, stepDepth: 0.3, x: 0, y: 0, z: 0 },
                color: '#868e96'
            },
            'roof': {
                title: 'Roof',
                icon: '△',
                inputs: [],
                outputs: ['Geometry'],
                params: { width: 12, length: 10, height: 3, x: 0, y: 5, z: 0 },
                color: '#c92a2a'
            },
            'array': {
                title: 'Array',
                icon: '▦',
                inputs: ['Geometry'],
                outputs: ['Geometry'],
                params: { countX: 3, countY: 1, countZ: 1, offsetX: 5, offsetY: 0, offsetZ: 0 },
                color: '#7950f2'
            },
            'transform': {
                title: 'Transform',
                icon: '⤨',
                inputs: ['Geometry'],
                outputs: ['Geometry'],
                params: { x: 0, y: 0, z: 0, rotX: 0, rotY: 0, rotZ: 0, scale: 1 },
                color: '#f76707'
            },
            'material': {
                title: 'Material',
                icon: '🎨',
                inputs: ['Geometry'],
                outputs: ['Geometry'],
                params: { color: '#4a90e2', metalness: 0.3, roughness: 0.5 },
                color: '#f06595'
            },
            'output': {
                title: 'Output',
                icon: '→',
                inputs: ['Geometry'],
                outputs: [],
                params: {},
                color: '#00e5ff'
            },
            'subtract': {
                title: 'Subtract',
                icon: '−',
                inputs: ['A', 'B'],
                outputs: ['Result'],
                params: {},
                color: '#e67e22'
            }
        };

        // Drag and drop setup
        document.querySelectorAll('.palette-node').forEach(node => {
            node.addEventListener('dragstart', (e) => {
                const type = e.currentTarget.dataset.type;
                e.dataTransfer.setData('nodeType', type);
                e.dataTransfer.effectAllowed = 'copy';
            });
        });

        canvasContainer.addEventListener('dragover', (e) => {
            e.preventDefault();
            e.dataTransfer.dropEffect = 'copy';
        });

        canvasContainer.addEventListener('drop', (e) => {
            e.preventDefault();
            const nodeType = e.dataTransfer.getData('nodeType');
            if (nodeType && nodeTemplates[nodeType]) {
                const rect = canvasContainer.getBoundingClientRect();
                const x = (e.clientX - rect.left - canvasOffset.x) / zoom;
                const y = (e.clientY - rect.top - canvasOffset.y) / zoom;
                createNode(nodeType, x, y);
            }
        });

        function createNode(type, x, y) {
            const template = nodeTemplates[type];
            if (!template) return;

            const node = {
                id: nodeIdCounter++,
                type,
                x,
                y,
                ...template
            };

            nodes.push(node);
            renderNode(node);
            updateStats();
        }

        function renderNode(node) {
            const nodeEl = document.createElement('div');
            nodeEl.className = 'workflow-node';
            nodeEl.id = `node-${node.id}`;
            nodeEl.style.left = `${node.x}px`;
            nodeEl.style.top = `${node.y}px`;

            let paramsHTML = '';
            if (node.params && Object.keys(node.params).length > 0) {
                Object.entries(node.params).forEach(([key, value]) => {
                    const inputType = typeof value === 'number' ? 'number' :
                                    key === 'color' ? 'color' : 'text';
                    const step = typeof value === 'number' && value < 1 ? '0.1' : '1';

                    paramsHTML += `
                        <div class="node-param">
                            <div class="port input">
                                <div class="port-dot" data-node="${node.id}" data-port="${key}" data-type="param-input"></div>
                                <div class="param-label">${key}</div>
                            </div>
                            <input type="${inputType}"
                                   class="param-input"
                                   value="${value}"
                                   step="${step}"
                                   data-param="${key}"
                                   onchange="updateNodeParam(${node.id}, '${key}', this.value, '${inputType}')">
                        </div>
                    `;
                });
            }

            let portsHTML = '';
            if (node.inputs && node.inputs.length > 0) {
                portsHTML += '<div class="node-ports">';
                node.inputs.forEach((input, idx) => {
                    portsHTML += `
                        <div class="port input">
                            <div class="port-dot" data-node="${node.id}" data-port="${idx}" data-type="input"></div>
                            <div class="port-label">${input}</div>
                        </div>
                    `;
                });
                portsHTML += '</div>';
            }

            if (node.outputs && node.outputs.length > 0) {
                portsHTML += '<div class="node-ports">';
                node.outputs.forEach((output, idx) => {
                    portsHTML += `
                        <div class="port output">
                            <div class="port-label">${output}</div>
                            <div class="port-dot" data-node="${node.id}" data-port="${idx}" data-type="output"></div>
                        </div>
                    `;
                });
                portsHTML += '</div>';
            }

            nodeEl.innerHTML = `
                <div class="node-header">
                    <span class="node-header-icon">${node.icon}</span>
                    <span class="node-header-title">${node.title}</span>
                </div>
                <div class="node-body">
                    ${paramsHTML}
                    ${portsHTML}
                </div>
            `;

            canvas.appendChild(nodeEl);
            makeNodeDraggable(nodeEl, node);

            // Port connections
            nodeEl.querySelectorAll('.port-dot').forEach(dot => {
                dot.addEventListener('mousedown', (e) => {
                    e.stopPropagation();
                    handlePortClick(dot);
                });
            });

            // Node selection
            nodeEl.addEventListener('click', (e) => {
                if (!e.target.classList.contains('port-dot') && 
                    !e.target.classList.contains('param-input')) {
                    selectNode(node);
                }
            });
        }

        function makeNodeDraggable(element, node) {
            let isDragging = false;
            let dragStartX, dragStartY;

            const header = element.querySelector('.node-header');
            
            header.addEventListener('mousedown', (e) => {
                if (e.button === 0) {
                    isDragging = true;
                    dragStartX = e.clientX - node.x * zoom;
                    dragStartY = e.clientY - node.y * zoom;
                    e.stopPropagation();
                }
            });

            const handleMouseMove = (e) => {
                if (isDragging) {
                    node.x = (e.clientX - dragStartX) / zoom;
                    node.y = (e.clientY - dragStartY) / zoom;
                    element.style.left = `${node.x}px`;
                    element.style.top = `${node.y}px`;
                    updateConnections();
                }
            };

            const handleMouseUp = () => {
                isDragging = false;
            };

            document.addEventListener('mousemove', handleMouseMove);
            document.addEventListener('mouseup', handleMouseUp);
        }

        function handlePortClick(dot) {
            const nodeId = parseInt(dot.dataset.node);
            const port = dot.dataset.port;
            const type = dot.dataset.type;

            if (!connectingFrom) {
                connectingFrom = { nodeId, port, type };
                dot.style.transform = 'scale(1.5)';
            } else {
                if (connectingFrom.type !== type && connectingFrom.nodeId !== nodeId) {
                    const connection = connectingFrom.type === 'output'
                        ? { from: connectingFrom, to: { nodeId, port, type } }
                        : { from: { nodeId, port, type }, to: connectingFrom };
                    
                    // Prevent multiple connections to the same input port
                    if (!connections.some(c => c.to.nodeId === connection.to.nodeId && c.to.port === connection.to.port)) {
                        connections.push(connection);
                        if(connection.to.type === 'param-input') {
                            const inputEl = document.querySelector(`#node-${connection.to.nodeId} [data-param="${connection.to.port}"]`);
                            if(inputEl) inputEl.disabled = true;
                        }
                    }
                    updateConnections();
                    updateStats();
                }

                document.querySelectorAll('.port-dot').forEach(d => {
                    d.style.transform = '';
                });
                connectingFrom = null;
            }
        }

        function updateConnections() {
            connectionsSvg.innerHTML = '';
            
            connections.forEach((conn, index) => {
                const fromNode = nodes.find(n => n.id === conn.from.nodeId);
                const toNode = nodes.find(n => n.id === conn.to.nodeId);
                
                if (!fromNode || !toNode) return;

                const fromSelector = `#node-${fromNode.id} .port.output .port-dot[data-port="${conn.from.port}"]`;
                const toSelector = `#node-${toNode.id} .port-dot[data-port="${conn.to.port}"]`;

                const fromEl = document.querySelector(fromSelector);
                const toEl = document.querySelector(toSelector);

                if (!fromEl || !toEl) return;

                const fromRect = fromEl.getBoundingClientRect();
                const toRect = toEl.getBoundingClientRect();
                const containerRect = canvasContainer.getBoundingClientRect();

                const x1 = fromRect.left + fromRect.width / 2 - containerRect.left;
                const y1 = fromRect.top + fromRect.height / 2 - containerRect.top;
                const x2 = toRect.left + toRect.width / 2 - containerRect.left;
                const y2 = toRect.top + toRect.height / 2 - containerRect.top;

                const dx = x2 - x1;
                const controlOffset = Math.abs(dx) * 0.5;

                const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                path.setAttribute('class', 'connection-path');
                if (selectedNode && (conn.from.nodeId === selectedNode.id || conn.to.nodeId === selectedNode.id)) {
                    path.classList.add('selected');
                }
                path.setAttribute('d', `M ${x1} ${y1} C ${x1 + controlOffset} ${y1}, ${x2 - controlOffset} ${y2}, ${x2} ${y2}`);
                path.addEventListener('contextmenu', (e) => {
                    e.preventDefault();
                    connections.splice(index, 1);
                    if(conn.to.type === 'param-input') {
                        const inputEl = document.querySelector(`#node-${conn.to.nodeId} [data-param="${conn.to.port}"]`);
                        if(inputEl) inputEl.disabled = false;
                    }
                    updateConnections();
                    updateStats();
                });
                connectionsSvg.appendChild(path);
            });
        }

        function updateNodeParam(nodeId, paramName, value, inputType) {
            const node = nodes.find(n => n.id === nodeId);
            if (node && node.params) {
                if (inputType === 'number') {
                    node.params[paramName] = parseFloat(value) || 0;
                } else {
                    node.params[paramName] = value;
                }
                
                if (selectedNode && selectedNode.id === nodeId) {
                    showNodeProperties(node);
                }
            }
        }

        function selectNode(node) {
            document.querySelectorAll('.workflow-node').forEach(el => {
                el.classList.remove('selected');
            });
            selectedNode = node;
            const nodeEl = document.getElementById(`node-${node.id}`);
            if (nodeEl) {
                nodeEl.classList.add('selected');
            }
            showNodeProperties(node);
            updateConnections();
        }

        function showNodeProperties(node) {
            const propSection = document.getElementById('node-properties');
            const propContent = document.getElementById('properties-content');
            
            propSection.style.display = 'block';
            
            let html = `<div style="margin-bottom: 16px; padding-bottom: 12px; border-bottom: 1px solid var(--node-border);">
                            <div style="font-size: 13px; font-weight: 600; color: var(--accent);">${node.title} #${node.id}</div>
                            <div style="font-size: 10px; color: var(--text-secondary); margin-top: 4px;">Type: ${node.type}</div>
                        </div>`;
            
            if (node.params && Object.keys(node.params).length > 0) {
                Object.entries(node.params).forEach(([key, value]) => {
                    if (typeof value === 'number') {
                        const max = key.includes('segments') ? 64 : key.includes('steps') ? 30 : 50;
                        const step = value < 1 ? 0.1 : 1;
                        html += `
                            <div class="prop-group">
                                <label class="prop-label">
                                    <span>${key}</span>
                                    <span class="prop-value">${value}</span>
                                </label>
                                <input type="range" class="prop-slider" 
                                       min="0" max="${max}" step="${step}" value="${value}"
                                       oninput="updateNodeParamLive(${node.id}, '${key}', this.value)">
                            </div>
                        `;
                    } else if (key === 'color') {
                        html += `
                            <div class="prop-group">
                                <label class="prop-label">${key}</label>
                                <input type="color" class="prop-input" value="${value}"
                                       onchange="updateNodeParamLive(${node.id}, '${key}', this.value)">
                            </div>
                        `;
                    } else {
                        html += `
                            <div class="prop-group">
                                <label class="prop-label">${key}</label>
                                <input type="text" class="prop-input" value="${value}"
                                       onchange="updateNodeParamLive(${node.id}, '${key}', this.value)">
                            </div>
                        `;
                    }
                });
            }
            
            propContent.innerHTML = html;
        }

        function updateNodeParamLive(nodeId, paramName, value) {
            const node = nodes.find(n => n.id === nodeId);
            if (node && node.params) {
                const numValue = parseFloat(value);
                node.params[paramName] = isNaN(numValue) ? value : numValue;
                
                // Update node input
                const nodeEl = document.getElementById(`node-${nodeId}`);
                if (nodeEl) {
                    const input = nodeEl.querySelector(`[data-param="${paramName}"]`);
                    if (input) {
                        input.value = value;
                    }
                }
                
                // Update property display
                const propValueEl = document.querySelector(`#properties-content .prop-group .prop-value`);
                if (propValueEl) {
                    const labels = document.querySelectorAll('#properties-content .prop-label');
                    labels.forEach(label => {
                        if (label.textContent.includes(paramName)) {
                            const valueSpan = label.querySelector('.prop-value');
                            if (valueSpan) {
                                valueSpan.textContent = value;
                            }
                        }
                    });
                }
            }
        }

        // Canvas panning and context menu
        canvasContainer.addEventListener('mousedown', (e) => {
            if ((e.target === canvasContainer || e.target === canvas || e.target === connectionsSvg) && e.button === 0) {
                isPanning = true;
                panStart = { x: e.clientX - canvasOffset.x, y: e.clientY - canvasOffset.y };
                canvas.classList.add('panning');
            }
        });

        canvasContainer.addEventListener('contextmenu', (e) => {
            e.preventDefault();
            const contextMenu = document.getElementById('context-menu');
            contextMenu.style.display = 'block';
            contextMenu.style.left = `${e.clientX}px`;
            contextMenu.style.top = `${e.clientY}px`;
            populateContextMenu();
        });

        function populateContextMenu() {
            const contextMenu = document.getElementById('context-menu');
            let menuHTML = '';
            for (const type in nodeTemplates) {
                const template = nodeTemplates[type];
                menuHTML += `
                    <div class="context-menu-item" onclick="addNodeFromContextMenu('${type}')">
                        <span class="context-menu-icon">${template.icon}</span>
                        <span>${template.title}</span>
                    </div>
                `;
            }
            contextMenu.innerHTML = menuHTML;
        }

        function addNodeFromContextMenu(type) {
            const contextMenu = document.getElementById('context-menu');
            const rect = canvasContainer.getBoundingClientRect();
            const x = (parseInt(contextMenu.style.left, 10) - rect.left - canvasOffset.x) / zoom;
            const y = (parseInt(contextMenu.style.top, 10) - rect.top - canvasOffset.y) / zoom;
            createNode(type, x, y);
            contextMenu.style.display = 'none';
        }

        document.addEventListener('click', (e) => {
            const contextMenu = document.getElementById('context-menu');
            if (contextMenu.style.display === 'block') {
                contextMenu.style.display = 'none';
            }
        });

        document.addEventListener('mousemove', (e) => {
            if (isPanning) {
                canvasOffset.x = e.clientX - panStart.x;
                canvasOffset.y = e.clientY - panStart.y;
                canvas.style.transform = `translate(${canvasOffset.x}px, ${canvasOffset.y}px) scale(${zoom})`;
                updateConnections();
            }
        });

        document.addEventListener('mouseup', () => {
            if (isPanning) {
                isPanning = false;
                canvas.classList.remove('panning');
            }
        });

        function zoomCanvas(direction) {
            if (direction === 'in') {
                zoom = Math.min(zoom + 0.1, 2);
            } else {
                zoom = Math.max(zoom - 0.1, 0.5);
            }
            canvas.style.transform = `translate(${canvasOffset.x}px, ${canvasOffset.y}px) scale(${zoom})`;
            document.getElementById('zoom-level').textContent = `${Math.round(zoom * 100)}%`;
            updateConnections();
        }

        function resetZoom() {
            zoom = 1;
            canvasOffset = { x: 0, y: 0 };
            canvas.style.transform = 'translate(0px, 0px) scale(1)';
            document.getElementById('zoom-level').textContent = '100%';
            updateConnections();
        }

        function updateStats() {
            document.getElementById('node-count').textContent = nodes.length;
            document.getElementById('connection-count').textContent = connections.length;
        }

        // Generate 3D model from node graph
        function generateModel() {
            // Clear existing objects
            sceneObjects.forEach(obj => {
                scene.remove(obj);
                if (obj.geometry) obj.geometry.dispose();
                if (obj.material) {
                    if (Array.isArray(obj.material)) {
                        obj.material.forEach(m => m.dispose());
                    } else {
                        obj.material.dispose();
                    }
                }
            });
            sceneObjects = [];

            const executed = new Map();

            function executeNode(node) {
                if (executed.has(node.id)) {
                    return executed.get(node.id);
                }

                // Animate node
                const nodeEl = document.getElementById(`node-${node.id}`);
                if (nodeEl) {
                    nodeEl.classList.add('executing');
                    setTimeout(() => nodeEl.classList.remove('executing'), 600);
                }

                // Get inputs
                const inputConnections = connections.filter(c => c.to.nodeId === node.id && c.to.type === 'input');
                const inputs = inputConnections.map(conn => {
                    const sourceNode = nodes.find(n => n.id === conn.from.nodeId);
                    return sourceNode ? executeNode(sourceNode) : null;
                });

                // Get params from connections or local values
                const p = {};
                if(node.params) {
                    for(const key in node.params) {
                        const paramConnection = connections.find(c => c.to.nodeId === node.id && c.to.port === key);
                        if(paramConnection) {
                            const sourceNode = nodes.find(n => n.id === paramConnection.from.nodeId);
                            p[key] = sourceNode ? executeNode(sourceNode) : node.params[key];
                        } else {
                            p[key] = node.params[key];
                        }
                    }
                }

                // Execute based on type
                let result = null;

                switch(node.type) {
                    case 'number':
                        result = p.value || 0;
                        break;
                    case 'box':
                        const boxGeom = new THREE.BoxGeometry(p.width || 5, p.height || 5, p.depth || 5);
                        const boxMat = new THREE.MeshStandardMaterial({ 
                            color: node.color || 0x4a90e2, 
                            metalness: 0.3, 
                            roughness: 0.5 
                        });
                        result = new THREE.Mesh(boxGeom, boxMat);
                        result.position.set(p.x || 0, p.y || 2.5, p.z || 0);
                        break;

                    case 'cylinder':
                        const cylGeom = new THREE.CylinderGeometry(
                            p.radius || 2, p.radius || 2, p.height || 5, p.segments || 32
                        );
                        const cylMat = new THREE.MeshStandardMaterial({ 
                            color: node.color || 0x5c7cfa, 
                            metalness: 0.3, 
                            roughness: 0.5 
                        });
                        result = new THREE.Mesh(cylGeom, cylMat);
                        result.position.set(p.x || 0, p.y || 2.5, p.z || 0);
                        break;

                    case 'sphere':
                        const sphereGeom = new THREE.SphereGeometry(p.radius || 3, p.segments || 32, p.segments || 32);
                        const sphereMat = new THREE.MeshStandardMaterial({ 
                            color: node.color || 0x748ffc, 
                            metalness: 0.3, 
                            roughness: 0.5 
                        });
                        result = new THREE.Mesh(sphereGeom, sphereMat);
                        result.position.set(p.x || 0, p.y || 3, p.z || 0);
                        break;

                    case 'plane':
                        const planeGeom = new THREE.PlaneGeometry(p.width || 20, p.height || 20);
                        const planeMat = new THREE.MeshStandardMaterial({ 
                            color: node.color || 0x868e96, 
                            metalness: 0.1, 
                            roughness: 0.9,
                            side: THREE.DoubleSide 
                        });
                        result = new THREE.Mesh(planeGeom, planeMat);
                        result.rotation.x = -Math.PI / 2;
                        result.position.set(p.x || 0, p.y || 0, p.z || 0);
                        break;

                    case 'wall':
                        const wallGeom = new THREE.BoxGeometry(p.length || 10, p.height || 3, p.thickness || 0.2);
                        const wallMat = new THREE.MeshStandardMaterial({ 
                            color: node.color || 0xcccccc, 
                            metalness: 0.1, 
                            roughness: 0.9 
                        });
                        result = new THREE.Mesh(wallGeom, wallMat);
                        result.position.set(p.x || 0, p.y || 1.5, p.z || 0);
                        break;

                    case 'window':
                        const windowGroup = new THREE.Group();
                        const frameThickness = 0.05;
                        const frameMat = new THREE.MeshStandardMaterial({ color: 0x333333 });
                        
                        // Frame parts
                        const topFrame = new THREE.Mesh(
                            new THREE.BoxGeometry(p.width || 2, frameThickness, p.depth || 0.3),
                            frameMat
                        );
                        topFrame.position.y = (p.height || 1.5) / 2;
                        windowGroup.add(topFrame);
                        
                        const bottomFrame = topFrame.clone();
                        bottomFrame.position.y = -(p.height || 1.5) / 2;
                        windowGroup.add(bottomFrame);
                        
                        const leftFrame = new THREE.Mesh(
                            new THREE.BoxGeometry(frameThickness, p.height || 1.5, p.depth || 0.3),
                            frameMat
                        );
                        leftFrame.position.x = -(p.width || 2) / 2;
                        windowGroup.add(leftFrame);
                        
                        const rightFrame = leftFrame.clone();
                        rightFrame.position.x = (p.width || 2) / 2;
                        windowGroup.add(rightFrame);
                        
                        // Glass
                        const glassMat = new THREE.MeshPhysicalMaterial({ 
                            color: 0x88ccff, 
                            metalness: 0, 
                            roughness: 0.1,
                            transparent: true,
                            opacity: 0.4,
                            transmission: 0.9
                        });
                        const glass = new THREE.Mesh(
                            new THREE.BoxGeometry(
                                (p.width || 2) - frameThickness * 2, 
                                (p.height || 1.5) - frameThickness * 2, 
                                0.02
                            ),
                            glassMat
                        );
                        windowGroup.add(glass);
                        windowGroup.position.set(p.x || 0, p.y || 1.5, p.z || 0);
                        result = windowGroup;
                        break;

                    case 'door':
                        const doorGroup = new THREE.Group();
                        const doorMat = new THREE.MeshStandardMaterial({ 
                            color: 0x8b4513, 
                            metalness: 0.2, 
                            roughness: 0.8 
                        });
                        const doorPanel = new THREE.Mesh(
                            new THREE.BoxGeometry(p.width || 1, p.height || 2.2, p.depth || 0.1),
                            doorMat
                        );
                        doorGroup.add(doorPanel);
                        
                        const handleMat = new THREE.MeshStandardMaterial({ 
                            color: 0xcccccc, 
                            metalness: 0.8, 
                            roughness: 0.2 
                        });
                        const handle = new THREE.Mesh(
                            new THREE.CylinderGeometry(0.03, 0.03, 0.15, 8),
                            handleMat
                        );
                        handle.rotation.z = Math.PI / 2;
                        handle.position.set((p.width || 1) * 0.4, 0, (p.depth || 0.1) / 2 + 0.05);
                        doorGroup.add(handle);
                        
                        doorGroup.position.set(p.x || 0, p.y || 1.1, p.z || 0);
                        result = doorGroup;
                        break;

                    case 'stairs':
                        const stairsGroup = new THREE.Group();
                        const stepMat = new THREE.MeshStandardMaterial({ 
                            color: node.color || 0x999999, 
                            metalness: 0.2, 
                            roughness: 0.7 
                        });
                        
                        for (let i = 0; i < (p.steps || 10); i++) {
                            const step = new THREE.Mesh(
                                new THREE.BoxGeometry(p.width || 3, p.stepHeight || 0.2, p.stepDepth || 0.3),
                                stepMat
                            );
                            step.position.set(
                                0, 
                                i * (p.stepHeight || 0.2) + (p.stepHeight || 0.2) / 2, 
                                i * (p.stepDepth || 0.3)
                            );
                            stairsGroup.add(step);
                        }
                        stairsGroup.position.set(p.x || 0, p.y || 0, p.z || 0);
                        result = stairsGroup;
                        break;

                    case 'roof':
                        const roofGroup = new THREE.Group();
                        const roofMat = new THREE.MeshStandardMaterial({ 
                            color: node.color || 0xc92a2a, 
                            metalness: 0.3, 
                            roughness: 0.7 
                        });
                        
                        const slopeLength = Math.sqrt((p.height || 3) ** 2 + ((p.length || 10) / 2) ** 2);
                        const slopeAngle = Math.atan2(p.height || 3, (p.length || 10) / 2);
                        
                        const slope1 = new THREE.Mesh(
                            new THREE.BoxGeometry(p.width || 12, 0.2, slopeLength),
                            roofMat
                        );
                        slope1.rotation.x = slopeAngle;
                        slope1.position.set(0, (p.height || 3) / 2, (p.length || 10) / 4);
                        roofGroup.add(slope1);
                        
                        const slope2 = slope1.clone();
                        slope2.rotation.x = -slopeAngle;
                        slope2.position.z = -(p.length || 10) / 4;
                        roofGroup.add(slope2);
                        
                        roofGroup.position.set(p.x || 0, p.y || 5, p.z || 0);
                        result = roofGroup;
                        break;

                    case 'array':
                        if (inputs[0]) {
                            const arrayGroup = new THREE.Group();
                            for (let x = 0; x < (p.countX || 3); x++) {
                                for (let y = 0; y < (p.countY || 1); y++) {
                                    for (let z = 0; z < (p.countZ || 1); z++) {
                                        const clone = inputs[0].clone();
                                        clone.position.x += x * (p.offsetX || 5);
                                        clone.position.y += y * (p.offsetY || 0);
                                        clone.position.z += z * (p.offsetZ || 0);
                                        arrayGroup.add(clone);
                                    }
                                }
                            }
                            result = arrayGroup;
                        }
                        break;

                    case 'transform':
                        if (inputs[0]) {
                            result = inputs[0].clone();
                            result.position.set(p.x || 0, p.y || 0, p.z || 0);
                            result.rotation.set(
                                (p.rotX || 0) * Math.PI / 180, 
                                (p.rotY || 0) * Math.PI / 180, 
                                (p.rotZ || 0) * Math.PI / 180
                            );
                            result.scale.setScalar(p.scale || 1);
                        }
                        break;

                    case 'material':
                        if (inputs[0]) {
                            result = inputs[0].clone();
                            const newMat = new THREE.MeshStandardMaterial({
                                color: p.color || '#4a90e2',
                                metalness: p.metalness || 0.3,
                                roughness: p.roughness || 0.5
                            });
                            result.traverse((child) => {
                                if (child.isMesh) {
                                    child.material = newMat.clone();
                                }
                            });
                        }
                        break;

                    case 'output':
                        result = inputs[0] || null;
                        break;
                    case 'subtract':
                        if (inputs[0] && inputs[1]) {
                            const csg = new ThreeCSG();
                            csg.subtract(inputs[0], inputs[1]);
                            result = csg.toMesh();
                        }
                        break;
                }

                executed.set(node.id, result);
                return result;
            }

            // Execute all output nodes
            const outputNodes = nodes.filter(n => n.type === 'output');
            if (outputNodes.length > 0) {
                outputNodes.forEach(node => {
                    const result = executeNode(node);
                    if (result) {
                        scene.add(result);
                        sceneObjects.push(result);
                    }
                });
            } else {
                // Execute standalone nodes
                nodes.forEach(node => {
                    if (!executed.has(node.id) && (!node.inputs || node.inputs.length === 0)) {
                        const result = executeNode(node);
                        if (result) {
                            scene.add(result);
                            sceneObjects.push(result);
                        }
                    }
                });
            }

            updateViewportStats();
            updateGeometryList();
        }

        function updateGeometryList() {
            const list = document.getElementById('geometry-list');
            
            if (sceneObjects.length === 0) {
                list.innerHTML = '<div class="empty-state">No objects yet.<br>Create a workflow and click Generate!</div>';
                return;
            }
            
            let html = '';
            sceneObjects.forEach((obj, idx) => {
                const typeName = obj.type === 'Group' ? `Group (${obj.children.length} items)` : 
                                 obj.geometry ? obj.geometry.type.replace('Geometry', '') : 'Object';
                html += `
                    <div class="geometry-item">
                        <span>${typeName} #${idx}</span>
                        <button class="delete-btn" onclick="removeSceneObject(${idx})">Delete</button>
                    </div>
                `;
            });
            
            list.innerHTML = html;
        }

        function removeSceneObject(idx) {
            if (idx >= 0 && idx < sceneObjects.length) {
                const obj = sceneObjects[idx];
                scene.remove(obj);
                if (obj.geometry) obj.geometry.dispose();
                if (obj.material) {
                    if (Array.isArray(obj.material)) {
                        obj.material.forEach(m => m.dispose());
                    } else {
                        obj.material.dispose();
                    }
                }
                sceneObjects.splice(idx, 1);
                updateGeometryList();
                updateViewportStats();
            }
        }

        function clearAll() {
            if (confirm('Clear all nodes and scene objects?')) {
                // Clear nodes
                nodes.forEach(node => {
                    const nodeEl = document.getElementById(`node-${node.id}`);
                    if (nodeEl) nodeEl.remove();
                });
                nodes = [];
                connections = [];
                connectionsSvg.innerHTML = '';
                
                // Clear scene
                sceneObjects.forEach(obj => {
                    scene.remove(obj);
                    if (obj.geometry) obj.geometry.dispose();
                    if (obj.material) {
                        if (Array.isArray(obj.material)) {
                            obj.material.forEach(m => m.dispose());
                        } else {
                            obj.material.dispose();
                        }
                    }
                });
                sceneObjects = [];
                
                updateStats();
                updateViewportStats();
                updateGeometryList();
                
                document.getElementById('node-properties').style.display = 'none';
                selectedNode = null;
            }
        }

        // Keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Delete' && selectedNode) {
                // Remove connections
                connections = connections.filter(c => 
                    c.from.nodeId !== selectedNode.id && c.to.nodeId !== selectedNode.id
                );
                
                // Remove node
                const nodeEl = document.getElementById(`node-${selectedNode.id}`);
                if (nodeEl) nodeEl.remove();
                
                nodes = nodes.filter(n => n.id !== selectedNode.id);
                selectedNode = null;
                
                updateConnections();
                updateStats();
                document.getElementById('node-properties').style.display = 'none';
            }
            
            if (e.key === 'g' && (e.ctrlKey || e.metaKey)) {
                e.preventDefault();
                generateModel();
            }
        });

        // Window resize
        window.addEventListener('resize', () => {
            const container = document.getElementById('viewport').parentElement;
            camera.aspect = container.clientWidth / container.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(container.clientWidth, container.clientHeight);
            updateConnections();
        });

        // Initialize with example workflow
        function initExampleWorkflow() {
            // Simple building example
            createNode('plane', 50, 50);
            createNode('wall', 50, 180);
            createNode('wall', 50, 310);
            createNode('window', 280, 180);
            createNode('door', 280, 310);
            createNode('roof', 50, 440);
            createNode('output', 500, 250);
            
            setTimeout(() => {
                // Connect nodes
                connections.push(
                    { from: { nodeId: 1, port: 0, type: 'output' }, to: { nodeId: 3, port: 0, type: 'input' } },
                    { from: { nodeId: 2, port: 0, type: 'output' }, to: { nodeId: 4, port: 0, type: 'input' } }
                );
                updateConnections();
                updateStats();
            }, 100);
        }

        // Initialize on load
        window.addEventListener('load', () => {
            initViewport();
            initExampleWorkflow();
        });
    </script>
</body>
</html>